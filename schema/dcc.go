// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *PersonName) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fnt"]; !ok || v == nil {
		return fmt.Errorf("field fnt: required")
	}
	type Plain PersonName
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PersonName(plain)
	return nil
}

// Country of Vaccination / Test, ISO 3166 alpha-2 where possible
type CountryVt string

// UnmarshalJSON implements json.Unmarshaler.
func (j *VaccinationEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ci"]; !ok || v == nil {
		return fmt.Errorf("field ci: required")
	}
	if v, ok := raw["co"]; !ok || v == nil {
		return fmt.Errorf("field co: required")
	}
	if v, ok := raw["dn"]; !ok || v == nil {
		return fmt.Errorf("field dn: required")
	}
	if v, ok := raw["dt"]; !ok || v == nil {
		return fmt.Errorf("field dt: required")
	}
	if v, ok := raw["is"]; !ok || v == nil {
		return fmt.Errorf("field is: required")
	}
	if v, ok := raw["ma"]; !ok || v == nil {
		return fmt.Errorf("field ma: required")
	}
	if v, ok := raw["mp"]; !ok || v == nil {
		return fmt.Errorf("field mp: required")
	}
	if v, ok := raw["sd"]; !ok || v == nil {
		return fmt.Errorf("field sd: required")
	}
	if v, ok := raw["tg"]; !ok || v == nil {
		return fmt.Errorf("field tg: required")
	}
	if v, ok := raw["vp"]; !ok || v == nil {
		return fmt.Errorf("field vp: required")
	}
	type Plain VaccinationEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VaccinationEntry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ci"]; !ok || v == nil {
		return fmt.Errorf("field ci: required")
	}
	if v, ok := raw["co"]; !ok || v == nil {
		return fmt.Errorf("field co: required")
	}
	if v, ok := raw["is"]; !ok || v == nil {
		return fmt.Errorf("field is: required")
	}
	if v, ok := raw["sc"]; !ok || v == nil {
		return fmt.Errorf("field sc: required")
	}
	if v, ok := raw["tg"]; !ok || v == nil {
		return fmt.Errorf("field tg: required")
	}
	if v, ok := raw["tr"]; !ok || v == nil {
		return fmt.Errorf("field tr: required")
	}
	if v, ok := raw["tt"]; !ok || v == nil {
		return fmt.Errorf("field tt: required")
	}
	type Plain TestEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TestEntry(plain)
	return nil
}

// Certificate Identifier, format as per UVCI: Annex 2 in
// https://ec.europa.eu/health/sites/health/files/ehealth/docs/vaccination-proof_interoperability-guidelines_en.pdf
type CertificateId string

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecoveryEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ci"]; !ok || v == nil {
		return fmt.Errorf("field ci: required")
	}
	if v, ok := raw["co"]; !ok || v == nil {
		return fmt.Errorf("field co: required")
	}
	if v, ok := raw["df"]; !ok || v == nil {
		return fmt.Errorf("field df: required")
	}
	if v, ok := raw["du"]; !ok || v == nil {
		return fmt.Errorf("field du: required")
	}
	if v, ok := raw["fr"]; !ok || v == nil {
		return fmt.Errorf("field fr: required")
	}
	if v, ok := raw["is"]; !ok || v == nil {
		return fmt.Errorf("field is: required")
	}
	if v, ok := raw["tg"]; !ok || v == nil {
		return fmt.Errorf("field tg: required")
	}
	type Plain RecoveryEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecoveryEntry(plain)
	return nil
}

// EU Digital Covid Certificate
type DCCCombinedSchemaJson struct {
	// Date of Birth of the person addressed in the DCC. ISO 8601 date format
	// restricted to range 1900-2099 or empty
	Dob *string `json:"dob,omitempty"`

	// Surname(s), forename(s) - in that order
	Nam *PersonName `json:"nam,omitempty"`

	// Recovery Group
	R []RecoveryEntry `json:"r,omitempty"`

	// Test Group
	T []TestEntry `json:"t,omitempty"`

	// Vaccination Group
	V []VaccinationEntry `json:"v,omitempty"`

	// Version of the schema, according to Semantic versioning (ISO,
	// https://semver.org/ version 2.0.0 or newer)
	Ver *string `json:"ver,omitempty"`
}

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.1
type DiseaseAgentTargeted string

// Dose Number / Total doses in Series: positive integer
type DosePosint int

// Certificate Issuer
type Issuer string

// Person name: Surname(s), forename(s) - in that order
type PersonName struct {
	// The surname or primary name(s) of the person addressed in the certificate
	Fn *string `json:"fn,omitempty"`

	// The surname(s) of the person, transliterated ICAO 9303
	Fnt string `json:"fnt"`

	// The forename(s) of the person addressed in the certificate
	Gn *string `json:"gn,omitempty"`

	// The forename(s) of the person, transliterated ICAO 9303
	Gnt *string `json:"gnt,omitempty"`
}

// Recovery Entry
type RecoveryEntry struct {
	// Unique Certificate Identifier, UVCI
	Ci CertificateId `json:"ci"`

	// Country of Test
	Co CountryVt `json:"co"`

	// ISO 8601 complete date: Certificate Valid From
	Df string `json:"df"`

	// ISO 8601 complete date: Certificate Valid Until
	Du string `json:"du"`

	// ISO 8601 complete date of first positive NAA test result
	Fr string `json:"fr"`

	// Certificate Issuer
	Is Issuer `json:"is"`

	// Tg corresponds to the JSON schema field "tg".
	Tg DiseaseAgentTargeted `json:"tg"`
}

// Test Entry
type TestEntry struct {
	// Unique Certificate Identifier, UVCI
	Ci CertificateId `json:"ci"`

	// Country of Test
	Co CountryVt `json:"co"`

	// Certificate Issuer
	Is Issuer `json:"is"`

	// RAT Test name and manufacturer
	Ma *TestManf `json:"ma,omitempty"`

	// NAA Test Name
	Nm *string `json:"nm,omitempty"`

	// Date/Time of Sample Collection
	Sc string `json:"sc"`

	// Testing Centre
	Tc *string `json:"tc,omitempty"`

	// Tg corresponds to the JSON schema field "tg".
	Tg DiseaseAgentTargeted `json:"tg"`

	// Test Result
	Tr TestResult `json:"tr"`

	// Type of Test
	Tt TestType `json:"tt"`
}

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.8
type TestManf string

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.9
type TestResult string

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.7
type TestType string

// Vaccination Entry
type VaccinationEntry struct {
	// Unique Certificate Identifier: UVCI
	Ci CertificateId `json:"ci"`

	// Country of Vaccination
	Co CountryVt `json:"co"`

	// Dose Number
	Dn DosePosint `json:"dn"`

	// ISO8601 complete date: Date of Vaccination
	Dt string `json:"dt"`

	// Certificate Issuer
	Is Issuer `json:"is"`

	// Marketing Authorization Holder - if no MAH present, then manufacturer
	Ma VaccineMahManf `json:"ma"`

	// vaccine medicinal product
	Mp VaccineMedicinalProduct `json:"mp"`

	// Total Series of Doses
	Sd DosePosint `json:"sd"`

	// disease or agent targeted
	Tg DiseaseAgentTargeted `json:"tg"`

	// vaccine or prophylaxis
	Vp VaccineProphylaxis `json:"vp"`
}

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.4
type VaccineMahManf string

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.3
type VaccineMedicinalProduct string

// EU eHealthNetwork: Value Sets for Digital Covid Certificates. version 1.0,
// 2021-04-16, section 2.2
type VaccineProphylaxis string
